//! TUI (Terminal User Interface) モジュール
//!
//! ratatuiを使用したリアルタイム進捗表示

use std::io::{self, Stdout};
use std::sync::{Arc, Mutex};

use crossterm::{
    event::{self, Event, KeyCode},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
    backend::CrosstermBackend,
    layout::{Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    symbols,
    text::{Line, Span},
    widgets::{Axis, Block, Borders, Chart, Dataset, Gauge, Paragraph, Wrap},
    Frame, Terminal,
};

use crate::evaluation::EvaluationWeights;
use crate::layout::Layout as KeyboardLayout;

/// TUI状態
pub struct TuiState {
    pub generation: usize,
    pub max_generations: usize,
    pub best_fitness: f64,
    pub fitness_history: Vec<f64>,
    pub best_layout: Option<KeyboardLayout>,
    pub weights: Option<EvaluationWeights>,
    pub running: bool,
    pub debug: bool,
}

impl TuiState {
    pub fn new(max_generations: usize) -> Self {
        Self::new_with_debug(max_generations, false)
    }
    
    pub fn new_with_debug(max_generations: usize, debug: bool) -> Self {
        Self {
            generation: 0,
            max_generations,
            best_fitness: 0.0,
            fitness_history: Vec::with_capacity(max_generations),
            best_layout: None,
            weights: None,
            running: true,
            debug,
        }
    }
    
    pub fn set_weights(&mut self, weights: EvaluationWeights) {
        self.weights = Some(weights);
    }

    pub fn update(&mut self, generation: usize, fitness: f64, layout: &KeyboardLayout) {
        self.generation = generation;
        if fitness > self.best_fitness {
            self.best_fitness = fitness;
            self.best_layout = Some(layout.clone());
        }
        self.fitness_history.push(fitness);
    }
}

/// TUIアプリケーション
pub struct TuiApp {
    terminal: Terminal<CrosstermBackend<Stdout>>,
}

impl TuiApp {
    /// TUIを初期化
    pub fn new() -> io::Result<Self> {
        enable_raw_mode()?;
        let mut stdout = io::stdout();
        execute!(stdout, EnterAlternateScreen)?;
        let backend = CrosstermBackend::new(stdout);
        let terminal = Terminal::new(backend)?;
        Ok(Self { terminal })
    }

    /// TUIを描画
    pub fn draw(&mut self, state: &TuiState) -> io::Result<()> {
        self.terminal.draw(|f| {
            let main_chunks = if state.debug {
                // デバッグモード: 上部を圧縮、下部を拡大
                Layout::default()
                    .direction(Direction::Vertical)
                    .margin(1)
                    .constraints([
                        Constraint::Length(3),   // Progress bar
                        Constraint::Length(8),   // Graph (小さく)
                        Constraint::Min(30),     // Layout + Scores + Debug (大きく)
                    ])
                    .split(f.area())
            } else {
                // 通常モード
                Layout::default()
                    .direction(Direction::Vertical)
                    .margin(1)
                    .constraints([
                        Constraint::Length(3),   // Progress bar
                        Constraint::Length(12),  // Graph
                        Constraint::Percentage(50), // Layout + Scores
                    ])
                    .split(f.area())
            };

            let bottom_chunks = Layout::default()
                .direction(Direction::Horizontal)
                .constraints([
                    Constraint::Percentage(50), // Layout
                    Constraint::Percentage(50), // Scores + Weights
                ])
                .split(main_chunks[2]);

            render_progress(f, main_chunks[0], state);
            render_graph(f, main_chunks[1], state);
            
            if state.debug {
                // デバッグモード: 2段構成（上段：キーボード+スコア、下段：デバッグ）
                let debug_rows = Layout::default()
                    .direction(Direction::Vertical)
                    .constraints([
                        Constraint::Length(18),  // 上段: キーボード+スコア
                        Constraint::Min(20),     // 下段: デバッグ（広く）
                    ])
                    .split(main_chunks[2]);
                
                // 上段を左右分割
                let top_chunks = Layout::default()
                    .direction(Direction::Horizontal)
                    .constraints([
                        Constraint::Percentage(45), // キーボード
                        Constraint::Percentage(55), // スコア
                    ])
                    .split(debug_rows[0]);
                
                render_keyboard(f, top_chunks[0], state);
                render_scores_and_weights(f, top_chunks[1], state);
                render_debug_panel(f, debug_rows[1], state); // 下段全幅でデバッグ
            } else {
                // 通常モード: 2分割
                render_keyboard(f, bottom_chunks[0], state);
                render_scores_and_weights(f, bottom_chunks[1], state);
            }
        })?;
        Ok(())
    }

    /// イベントをポーリング（ノンブロッキング）
    pub fn poll_event(&self) -> io::Result<bool> {
        if event::poll(std::time::Duration::from_millis(10))? {
            if let Event::Key(key) = event::read()? {
                if key.code == KeyCode::Char('q') || key.code == KeyCode::Esc {
                    return Ok(true);
                }
            }
        }
        Ok(false)
    }

    /// TUIを終了
    pub fn cleanup(mut self) -> io::Result<()> {
        disable_raw_mode()?;
        execute!(self.terminal.backend_mut(), LeaveAlternateScreen)?;
        self.terminal.show_cursor()?;
        Ok(())
    }
}

/// プログレスバーを描画（ETA追加）
fn render_progress(f: &mut Frame, area: Rect, state: &TuiState) {
    let progress = if state.max_generations > 0 {
        state.generation as f64 / state.max_generations as f64
    } else {
        0.0
    };

    // ETA推定（簡易版：最後10世代の平均速度から計算）
    let eta_str = if state.generation > 10 && state.generation < state.max_generations {
        let remaining = state.max_generations - state.generation;
        let eta_seconds = remaining as u64; // 1世代≈1秒と仮定（簡易版）
        let minutes = eta_seconds / 60;
        let seconds = eta_seconds % 60;
        format!(" | ETA: {}m{}s", minutes, seconds)
    } else {
        String::new()
    };

    let debug_indicator = if state.debug { " [★DEBUG★]" } else { "" };
    let title = format!("Progress{}", debug_indicator);
    
    let gauge = Gauge::default()
        .block(Block::default().borders(Borders::ALL).title(title))
        .gauge_style(Style::default().fg(Color::Cyan).bg(Color::Black))
        .percent((progress * 100.0) as u16)
        .label(format!(
            "Gen {}/{} | Best: {:.4}{}",
            state.generation, state.max_generations, state.best_fitness, eta_str
        ));

    f.render_widget(gauge, area);
}

/// フィットネスグラフを描画
fn render_graph(f: &mut Frame, area: Rect, state: &TuiState) {
    let data: Vec<(f64, f64)> = state
        .fitness_history
        .iter()
        .enumerate()
        .map(|(i, &f)| (i as f64, f))
        .collect();

    if data.is_empty() {
        let block = Block::default()
            .borders(Borders::ALL)
            .title("Fitness History");
        f.render_widget(block, area);
        return;
    }

    let min_fitness = state
        .fitness_history
        .iter()
        .cloned()
        .fold(f64::INFINITY, f64::min)
        .max(0.0);
    let max_fitness = state
        .fitness_history
        .iter()
        .cloned()
        .fold(f64::NEG_INFINITY, f64::max)
        .max(min_fitness + 1.0);

    let datasets = vec![Dataset::default()
        .name("Fitness")
        .marker(symbols::Marker::Braille)
        .style(Style::default().fg(Color::Yellow))
        .data(&data)];

    let chart = Chart::new(datasets)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("Fitness History (Gen 0 to Max)"),
        )
        .x_axis(
            Axis::default()
                .title("Generation")
                .style(Style::default().fg(Color::Gray))
                .bounds([0.0, state.max_generations as f64])
                .labels(vec![
                    Span::raw("0"),
                    Span::raw(format!("{}", state.max_generations / 2)),
                    Span::raw(format!("{}", state.max_generations)),
                ]),
        )
        .y_axis(
            Axis::default()
                .title("Fitness")
                .style(Style::default().fg(Color::Gray))
                .bounds([min_fitness - 5.0, max_fitness + 5.0])
                .labels(vec![
                    Span::raw(format!("{:.0}", min_fitness)),
                    Span::raw(format!("{:.0}", (min_fitness + max_fitness) / 2.0)),
                    Span::raw(format!("{:.0}", max_fitness)),
                ]),
        );

    f.render_widget(chart, area);
}

/// キーボード配列を描画
fn render_keyboard(f: &mut Frame, area: Rect, state: &TuiState) {
    let layout = match &state.best_layout {
        Some(l) => l,
        None => {
            let block = Block::default()
                .borders(Borders::ALL)
                .title("Best Layout");
            f.render_widget(block, area);
            return;
        }
    };

    let mut lines: Vec<Line> = vec![Line::from(Span::styled(
        format!("Fitness: {:.4}", state.best_fitness),
        Style::default()
            .fg(Color::Green)
            .add_modifier(Modifier::BOLD),
    ))];

    lines.push(Line::from(""));

    for (layer_idx, layer_name) in ["Layer 0 (無シフト)", "Layer 1 (☆)", "Layer 2 (★)"]
        .iter()
        .enumerate()
    {
        lines.push(Line::from(Span::styled(
            format!("{}:", layer_name),
            Style::default().fg(Color::Cyan),
        )));

        for row in 0..3 {
            let row_str: String = layout.layers[layer_idx][row]
                .iter()
                .map(|&c| if c == '　' { '□' } else { c })
                .collect::<Vec<_>>()
                .iter()
                .map(|c| format!("{} ", c))
                .collect();
            lines.push(Line::from(format!("  {}", row_str)));
        }
        lines.push(Line::from(""));
    }

    let paragraph = Paragraph::new(lines).block(
        Block::default()
            .borders(Borders::ALL)
            .title("Current Best Layout"),
    );

    f.render_widget(paragraph, area);
}

/// Colemak一致詳細を計算（評価関数と同じロジック）
fn calc_colemak_match_detail(layers: &[[[char; 10]; 3]; 3]) -> (usize, usize, usize) {
    use crate::layout::{romaji_phonemes, COLEMAK_POSITIONS};
    use std::collections::HashMap;
    
    // COLEMAK_POSITIONSから音素→位置のマップを作成
    let mut phoneme_pos: HashMap<&str, (usize, usize)> = HashMap::new();
    for &(phoneme, row, col) in COLEMAK_POSITIONS {
        phoneme_pos.insert(phoneme, (row, col));
    }
    
    let mut perfect = 0;  // 完全一致（両音素とも位置一致）
    let mut partial = 0;  // 部分一致（片方のみ一致または行/手一致）
    let mut total = 0;
    
    // 評価関数と同じく全レイヤーを評価（Layer 0重視）
    for layer in 0..3 {
        let layer_weight = if layer == 0 { 1.0 } else { 0.8 };
        
        for row in 0..3 {
            for col in 0..10 {
                let c = layers[layer][row][col];
                
                // 除外文字
                if c == '☆' || c == '★' || c == '、' || c == '。' || c == '　' ||
                   c == 'ー' || c == 'っ' || c == 'ゃ' || c == 'ゅ' || c == 'ょ' ||
                   c == 'ぁ' || c == 'ぃ' || c == 'ぅ' || c == 'ぇ' || c == 'ぉ' ||
                   c == '゛' || c == '゜' {
                    continue;
                }
                
                let (consonant, vowel) = romaji_phonemes(c);
                
                // 音素がない文字はスキップ
                if consonant.is_none() && vowel.is_none() {
                    continue;
                }
                
                total += 1;
                
                let mut cons_score = 0.0;
                let mut vowel_score = 0.0;
                
                // 子音チェック
                if let Some(cons) = consonant {
                    if let Some(&(exp_row, exp_col)) = phoneme_pos.get(cons) {
                        if row == exp_row && col == exp_col {
                            cons_score = 1.0;  // 完全一致
                        } else if row == exp_row {
                            cons_score = 0.5;  // 行一致
                        } else if (col < 5 && exp_col < 5) || (col >= 5 && exp_col >= 5) {
                            cons_score = 0.25; // 手一致
                        }
                    }
                }
                
                // 母音チェック
                if let Some(vow) = vowel {
                    if let Some(&(exp_row, exp_col)) = phoneme_pos.get(vow) {
                        if row == exp_row && col == exp_col {
                            vowel_score = 1.0;  // 完全一致
                        } else if row == exp_row {
                            vowel_score = 0.5;  // 行一致
                        } else if (col < 5 && exp_col < 5) || (col >= 5 && exp_col >= 5) {
                            vowel_score = 0.25; // 手一致
                        }
                    }
                }
                
                // スコアリング（簡略化: 完全一致と部分一致）
                let total_score = cons_score + vowel_score;
                if total_score >= 1.8 {  // ほぼ完全一致
                    perfect += 1;
                } else if total_score > 0.0 {  // 何らかの一致
                    partial += 1;
                }
            }
        }
    }
    
    (perfect, partial, total)
}

/// 月配列一致詳細を計算（ヘルパー関数）
fn calc_tsuki_match_detail(layers: &[[[char; 10]; 3]; 3]) -> (usize, usize) {
    let tsuki_layers = [
        [
            ['そ', 'こ', 'し', 'て', 'ょ', 'つ', 'ん', 'い', 'の', 'り'],
            ['は', 'か', '☆', 'と', 'た', 'く', 'う', '★', '゛', 'き'],
            ['す', 'け', 'に', 'な', 'さ', 'っ', 'る', '、', '。', '゜'],
        ],
        [
            ['ぁ', 'ひ', 'ほ', 'ふ', 'め', 'ぬ', 'え', 'み', 'や', 'ぇ'],
            ['ぃ', 'を', 'ら', 'あ', 'よ', 'ま', 'お', 'も', 'わ', 'ゆ'],
            ['ぅ', 'へ', 'せ', 'ゅ', 'ゃ', 'む', 'ろ', 'ね', 'ー', 'ぉ'],
        ],
    ];
    
    let mut matched = 0;
    let mut total = 0;
    
    for layer in 0..2 {
        for row in 0..3 {
            for col in 0..10 {
                let kana = layers[layer][row][col];
                let tsuki_char = tsuki_layers[layer][row][col];
                
                if kana == '★' || kana == '☆' || kana == '、' || kana == '。' || kana == '　' ||
                   tsuki_char == '★' || tsuki_char == '☆' || tsuki_char == '、' || tsuki_char == '。' ||
                   tsuki_char == '゛' || tsuki_char == '゜' || tsuki_char == '　' {
                    continue;
                }
                
                total += 1;
                if kana == tsuki_char {
                    matched += 1;
                }
            }
        }
    }
    (matched, total)
}

/// キーごとの位置コストを計算（評価ロジックと同じ）
fn calc_position_cost_for_key(pos: &crate::layout::KeyPos) -> f64 {
    // base_cost計算（評価と同じロジック）
    let base_cost = match pos.row {
        1 => 1.0,  // ホーム
        0 => match pos.col {
            0 | 9 => 3.0,     // 上段外側
            1 | 8 => 2.5,     // 上段薬指
            _ => 2.0,         // 上段その他
        },
        2 => match pos.col {
            0 | 9 => 3.0,     // 下段外側
            _ => 2.5,         // 下段その他
        },
        _ => 4.0,
    };
    
    let mut multiplier = 1.0;
    let layer_penalty = if pos.layer == 0 { 1.0 } else { 1.05 };
    
    if pos.layer == 1 {  // ☆シフト
        multiplier = 3.0 * layer_penalty;
        if pos.col == 7 && pos.row != 1 {  // Ver: ☆の上下
            multiplier += 27.0;
        }
        if pos.col >= 8 {  // Out: ☆より小指側
            multiplier += 9.0;
        }
    } else if pos.layer == 2 {  // ★シフト
        multiplier = 3.0 * layer_penalty;
        if pos.col == 2 && pos.row != 1 {  // Ver: ★の上下
            multiplier += 27.0;
        }
        if pos.col <= 1 {  // Out: ★より小指側
            multiplier += 9.0;
        }
    }
    
    base_cost * multiplier
}

/// デバッグパネルを描画（全計算過程・2カラム）
fn render_debug_panel(f: &mut Frame, area: Rect, state: &TuiState) {
    // 2カラムに分割
    let columns = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage(50), // 左カラム
            Constraint::Percentage(50), // 右カラム
        ])
        .split(area);
    
    // 左カラム: Core Metrics + Colemak詳細
    let mut left_lines = vec![];
    // 右カラム: 位置コスト + Bonus Metrics + Final
    let mut right_lines = vec![];
    
    if let (Some(layout), Some(w)) = (&state.best_layout, &state.weights) {
        let s = &layout.scores;
        let layers = &layout.layers;
        
        // === 左カラム: Core Metrics + Colemak詳細 ===
        left_lines.push(Line::from(Span::styled(
            "=== Core Metrics ===",
            Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD),
        )));
        left_lines.push(Line::from(""));
        
        left_lines.push(Line::from(Span::styled(
            "■ 計算式", 
            Style::default().fg(Color::Cyan)
        )));
        
        left_lines.push(Line::from(format!(
            "SFB: {:.1}%^{:.1}={:.3}",
            s.same_finger, w.same_finger,
            (s.same_finger/100.0).powf(w.same_finger)
        )));
        
        left_lines.push(Line::from(format!(
            "LSB: {:.1}%^{:.1}={:.3}",
            s.row_skip, w.row_skip,
            (s.row_skip/100.0).powf(w.row_skip)
        )));
        
        left_lines.push(Line::from(format!(
            "ホーム: {:.1}%^{:.1}={:.3}",
            s.home_position, w.home_position,
            (s.home_position/100.0).powf(w.home_position)
        )));
        
        left_lines.push(Line::from(format!(
            "打鍵: {:.1}%^{:.1}={:.3}",
            s.total_keystrokes, w.total_keystrokes,
            (s.total_keystrokes/100.0).powf(w.total_keystrokes)
        )));
        
        left_lines.push(Line::from(format!(
            "交互: {:.1}%^{:.1}={:.3}",
            s.alternating, w.alternating,
            (s.alternating/100.0).powf(w.alternating)
        )));
        
        left_lines.push(Line::from(format!(
            "単打: {:.1}%^{:.1}={:.3}",
            s.single_key, w.single_key,
            (s.single_key/100.0).powf(w.single_key)
        )));
        
        left_lines.push(Line::from(format!(
            "Colemak: {:.1}%^{:.1}={:.3}",
            s.colemak_similarity, w.colemak_similarity,
            (s.colemak_similarity/100.0).powf(w.colemak_similarity)
        )));
        
        left_lines.push(Line::from(format!(
            "位置: {:.1}%^{:.1}={:.3}",
            s.position_cost, w.position_cost,
            (s.position_cost/100.0).powf(w.position_cost)
        )));
        
        let core_product = (s.same_finger/100.0).powf(w.same_finger)
            * (s.row_skip/100.0).powf(w.row_skip)
            * (s.home_position/100.0).powf(w.home_position)
            * (s.total_keystrokes/100.0).powf(w.total_keystrokes)
            * (s.alternating/100.0).powf(w.alternating)
            * (s.single_key/100.0).powf(w.single_key)
            * (s.colemak_similarity/100.0).powf(w.colemak_similarity)
            * (s.position_cost/100.0).powf(w.position_cost);
        let total_weight = w.same_finger + w.row_skip + w.home_position 
            + w.total_keystrokes + w.alternating + w.single_key 
            + w.colemak_similarity + w.position_cost;
        let core_mult = core_product.powf(1.0 / total_weight) * 100.0;
        
        left_lines.push(Line::from(""));
        left_lines.push(Line::from(format!("→Core: {:.4}", core_mult)));
        
        // === Colemak類似詳細（キーごと採点：◎母音子音両一致/○片一致/×不一致） ===
        lines.push(Line::from(""));
        lines.push(Line::from(Span::styled(
            "■ Colemak一致キー配置（◎両一致/○片一致/×不一致）", 
            Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)
        )));
        
        // Colemak配列定義（英字→期待される音素）
        let colemak_layout = [
            ['q', 'w', 'f', 'p', 'g', 'j', 'l', 'u', 'y', ';'],
            ['a', 'r', 's', 't', 'd', 'h', 'n', 'e', 'i', 'o'],
            ['z', 'x', 'c', 'v', 'b', 'k', 'm', ',', '.', '/'],
        ];
        
        // 英字→音素マッピング（子音, 母音）
        let english_phonemes = |c: char| -> (Option<&str>, Option<&str>) {
            match c {
                'a' => (None, Some("a")),       // 母音のみ
                'e' => (None, Some("e")),
                'i' => (None, Some("i")),
                'o' => (None, Some("o")),
                'u' => (None, Some("u")),
                'k' => (Some("k"), None),       // 子音のみ
                's' => (Some("s"), None),
                't' => (Some("t"), None),
                'n' => (Some("n"), None),
                'h' => (Some("h"), None),
                'm' => (Some("m"), None),
                'y' => (Some("y"), None),
                'r' => (Some("r"), None),
                'w' => (Some("w"), None),
                'f' => (Some("f"), None),
                'p' => (Some("p"), None),
                'g' => (Some("g"), None),
                'd' => (Some("d"), None),
                'b' => (Some("b"), None),
                'z' => (Some("z"), None),
                'j' => (Some("j"), None),
                'l' => (Some("r"), None),       // lはrに対応
                _ => (None, None),
            }
        };
        
        // かな→音素マッピング（子音, 母音）
        use crate::layout::romaji_phonemes;
        
        let mut colemak_perfect_count = 0;  // ◎両一致
        let mut colemak_partial_count = 0;   // ○片一致
        let mut colemak_total_count = 0;
        
        for row in 0..3 {
            let mut match_line = String::new();
            for col in 0..10 {
                let kana = layers[0][row][col];
                let colemak_char = colemak_layout[row][col];
                
                // 記号・シフトキー・特殊文字は除外
                if kana == '★' || kana == '☆' || kana == '、' || kana == '。' || kana == '　' || 
                   kana == 'ー' || kana == 'っ' || kana == 'ゃ' || kana == 'ゅ' || kana == 'ょ' ||
                   kana == 'ぁ' || kana == 'ぃ' || kana == 'ぅ' || kana == 'ぇ' || kana == 'ぉ' ||
                   colemak_char == ',' || colemak_char == '.' || colemak_char == ';' {
                    match_line.push_str("  ");
                    continue;
                }
                
                colemak_total_count += 1;
                
                // 期待される音素（英字から）
                let (expected_cons, expected_vowel) = english_phonemes(colemak_char);
                
                // 実際の音素（かなから）
                let (actual_cons, actual_vowel) = romaji_phonemes(kana);
                
                // 両方の音素がNoneの場合はスキップ（判定不能）
                if expected_cons.is_none() && expected_vowel.is_none() && 
                   actual_cons.is_none() && actual_vowel.is_none() {
                    match_line.push_str("  ");
                    colemak_total_count -= 1;
                    continue;
                }
                
                // 一致判定
                let cons_match = match (expected_cons, actual_cons) {
                    (Some(e), Some(a)) => e == a,      // 両方あり→比較
                    (None, None) => true,               // 両方なし→一致
                    _ => false,                         // 片方のみ→不一致
                };
                
                let vowel_match = match (expected_vowel, actual_vowel) {
                    (Some(e), Some(a)) => e == a,      // 両方あり→比較
                    (None, None) => true,               // 両方なし→一致
                    _ => false,                         // 片方のみ→不一致
                };
                
                // ◎両一致 / ○片一致 / ×不一致
                if cons_match && vowel_match {
                    colemak_perfect_count += 1;
                    match_line.push('◎');
                } else if cons_match || vowel_match {
                    colemak_partial_count += 1;
                    match_line.push('○');
                } else {
                    match_line.push('×');
                }
                match_line.push(' ');
            }
            lines.push(Line::from(format!("  {}", match_line)));
        }
        
        let colemak_rate = if colemak_total_count > 0 {
            ((colemak_perfect_count + colemak_partial_count) as f64 / colemak_total_count as f64) * 100.0
        } else {
            0.0
        };
        lines.push(Line::from(format!(
            "→◎:{} ○:{} ×:{} | 一致率: {:.1}%",
            colemak_perfect_count, colemak_partial_count, 
            colemak_total_count - colemak_perfect_count - colemak_partial_count,
            colemak_rate
        )));
        
        // === 月配列類似詳細（キーごと採点） ===
        lines.push(Line::from(""));
        lines.push(Line::from(Span::styled(
            "■ 月配列一致キー配置（キーごと採点）", 
            Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)
        )));
        
        // 月配列2-236定義（直接定義）
        let tsuki_layers = [
            // Layer 0
            [
                ['そ', 'こ', 'し', 'て', 'ょ', 'つ', 'ん', 'い', 'の', 'り'],
                ['は', 'か', '☆', 'と', 'た', 'く', 'う', '★', '゛', 'き'],
                ['す', 'け', 'に', 'な', 'さ', 'っ', 'る', '、', '。', '゜'],
            ],
            // Layer 1（☆シフト）
            [
                ['ぁ', 'ひ', 'ほ', 'ふ', 'め', 'ぬ', 'え', 'み', 'や', 'ぇ'],
                ['ぃ', 'を', 'ら', 'あ', 'よ', 'ま', 'お', 'も', 'わ', 'ゆ'],
                ['ぅ', 'へ', 'せ', 'ゅ', 'ゃ', 'む', 'ろ', 'ね', 'ー', 'ぉ'],
            ],
            // Layer 2（★シフト） - 仮定義
            [
                ['　', '　', '　', '　', '　', '　', '　', '　', '　', '　'],
                ['　', '　', '　', '　', '　', '　', '　', '　', '　', '　'],
                ['　', '　', '　', '　', '　', '　', '　', '　', '　', '　'],
            ],
        ];
        
        let mut tsuki_match_count = 0;
        let mut tsuki_total_count = 0;
        
        for layer in 0..2 {  // Layer0とLayer1のみ比較
            let layer_name = match layer {
                0 => "L0",
                1 => "L1",
                _ => "",
            };
            lines.push(Line::from(format!("{}:", layer_name)));
            
            for row in 0..3 {
                let mut match_line = String::new();
                for col in 0..10 {
                    let kana = layers[layer][row][col];
                    let tsuki_char = tsuki_layers[layer][row][col];
                    
                    // 記号・シフトキー・空白は除外
                    if kana == '★' || kana == '☆' || kana == '、' || kana == '。' || kana == '　' || 
                       tsuki_char == '★' || tsuki_char == '☆' || tsuki_char == '、' || tsuki_char == '。' || 
                       tsuki_char == '゛' || tsuki_char == '゜' || tsuki_char == '　' {
                        match_line.push_str("  ");
                        continue;
                    }
                    
                    tsuki_total_count += 1;
                    
                    if kana == tsuki_char {
                        tsuki_match_count += 1;
                        match_line.push('○');
                    } else {
                        match_line.push('×');
                    }
                    match_line.push(' ');
                }
                lines.push(Line::from(format!("  {}", match_line)));
            }
        }
        
        let tsuki_rate = if tsuki_total_count > 0 {
            (tsuki_match_count as f64 / tsuki_total_count as f64) * 100.0
        } else {
            0.0
        };
        lines.push(Line::from(format!(
            "→一致: {}/{} = {:.1}% (L0+L1のみ)",
            tsuki_match_count, tsuki_total_count, tsuki_rate
        )));
        
        // === Position Cost詳細 ===
        lines.push(Line::from(""));
        lines.push(Line::from(Span::styled(
            "■ 位置コスト詳細", 
            Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)
        )));
        lines.push(Line::from("各レイヤーの高コストキー:"));
        lines.push(Line::from("L0: 上段外側・下段外側がペナルティ"));
        lines.push(Line::from("L1(☆): ☆キー(col7)上下+右小指側"));
        lines.push(Line::from("L2(★): ★キー(col2)上下+左小指側"));
        
        // === Bonus Metrics 詳細 ===
        lines.push(Line::from(""));
        lines.push(Line::from(Span::styled(
            "■ Bonus Metrics (加算)", 
            Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)
        )));
        
        lines.push(Line::from(format!(
            "リダイレクト: {:.1} × {:.1} = {:.1}",
            s.redirect_low, w.redirect_low, s.redirect_low * w.redirect_low
        )));
        
        lines.push(Line::from(format!(
            "月類似: {:.1} × {:.1} = {:.1}",
            s.tsuki_similarity, w.tsuki_similarity, s.tsuki_similarity * w.tsuki_similarity
        )));
        
        lines.push(Line::from(format!(
            "ロール: {:.2} × {:.1} = {:.1}",
            s.roll, w.roll, s.roll * w.roll
        )));
        
        lines.push(Line::from(format!(
            "インロール: {:.2} × {:.1} = {:.1}",
            s.inroll, w.inroll, s.inroll * w.inroll
        )));
        
        lines.push(Line::from(format!(
            "アルペジオ: {:.2} × {:.1} = {:.1}",
            s.arpeggio, w.arpeggio, s.arpeggio * w.arpeggio
        )));
        
        lines.push(Line::from(format!(
            "覚えやすさ: {:.1} × {:.1} = {:.1}",
            s.memorability, w.memorability, s.memorability * w.memorability
        )));
        
        lines.push(Line::from(format!(
            "シフトバランス: {:.1} × {:.1} = {:.1}",
            s.shift_balance, w.shift_balance, s.shift_balance * w.shift_balance
        )));
        
        let additive_bonus = s.redirect_low * w.redirect_low 
            + s.tsuki_similarity * w.tsuki_similarity
            + s.roll * w.roll + s.inroll * w.inroll 
            + s.arpeggio * w.arpeggio
            + s.memorability * w.memorability 
            + s.shift_balance * w.shift_balance;
        let bonus_scale = (w.redirect_low + w.tsuki_similarity + w.roll 
            + w.inroll + w.arpeggio + w.memorability + w.shift_balance) * 100.0;
        
        lines.push(Line::from(""));
        lines.push(Line::from(format!("→Bonus合計: {:.2}", additive_bonus)));
        lines.push(Line::from(format!("→Scale: {:.0}", bonus_scale)));
        lines.push(Line::from(format!("→比率: {:.4}", additive_bonus / bonus_scale)));
        
        // === 最終Fitness ===
        let final_fitness = core_mult * (1.0 + additive_bonus / bonus_scale);
        lines.push(Line::from(""));
        lines.push(Line::from(Span::styled(
            format!("■ Final Fitness: {:.4}", final_fitness),
            Style::default().fg(Color::Green).add_modifier(Modifier::BOLD),
        )));
        lines.push(Line::from(format!(
            "{:.2} × (1 + {:.4}) = {:.4}",
            core_mult, additive_bonus/bonus_scale, final_fitness
        )));
        
    } else {
        lines.push(Line::from("計算中..."));
    }
    
    let paragraph = Paragraph::new(lines)
        .block(
            Block::default()
                .title("★ Debug Panel (全計算過程) ★")
                .borders(Borders::ALL)
                .border_style(Style::default().fg(Color::Magenta)),
        )
        .wrap(Wrap { trim: false })
        .scroll((0, 0));
    
    f.render_widget(paragraph, area);
}

/// スコア詳細と重みを描画
fn render_scores_and_weights(f: &mut Frame, area: Rect, state: &TuiState) {
    let layout = match &state.best_layout {
        Some(l) => l,
        None => {
            let block = Block::default()
                .borders(Borders::ALL)
                .title("Scores & Weights");
            f.render_widget(block, area);
            return;
        }
    };

    let mut lines: Vec<Line> = vec![];
    let s = &layout.scores;
    let w = state.weights.as_ref();

    // Similarity & Scores（計算式付き）
    lines.push(Line::from(Span::styled(
        "=== Similarity & Scores ===",
        Style::default()
            .fg(Color::Green)
            .add_modifier(Modifier::BOLD),
    )));
    // Colemak一致率の詳細計算
    let (colemak_perfect, colemak_partial, colemak_total) = calc_colemak_match_detail(&layout.layers);
    lines.push(Line::from(format!(
        "Colemak:    {:.1}% (◎{} ○{} ×{})",
        s.colemak_similarity, colemak_perfect, colemak_partial,
        colemak_total - colemak_perfect - colemak_partial
    )));
    
    // 月配列一致率の詳細計算
    let (tsuki_match, tsuki_total) = calc_tsuki_match_detail(&layout.layers);
    lines.push(Line::from(format!(
        "月配列:     {:.1}% (○{} ×{})",
        s.tsuki_similarity, tsuki_match, tsuki_total - tsuki_match
    )));
    // 位置コストはCore metricsに移動

    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled(
        "=== Core Metrics ===",
        Style::default()
            .fg(Color::Yellow)
            .add_modifier(Modifier::BOLD),
    )));

    if let Some(weights) = w {
        lines.push(Line::from(format!(
            "同指連続低: {:.1}% ^{:.2} (1-SFB/bigram)",
            s.same_finger, weights.same_finger
        )));
        lines.push(Line::from(format!(
            "左右交互:   {:.1}% ^{:.2} (交互/bigram)",
            s.alternating, weights.alternating
        )));
        lines.push(Line::from(format!(
            "単打鍵率:   {:.1}% ^{:.2} (L0freq/全freq)",
            s.single_key, weights.single_key
        )));

        lines.push(Line::from(""));
        lines.push(Line::from(Span::styled(
            "=== Bonus ===",
            Style::default()
                .fg(Color::Cyan)
                .add_modifier(Modifier::BOLD),
        )));

        lines.push(Line::from(format!(
            "ロール:     {:.1} x{:.1} (roll/同手bigram)",
            s.roll, weights.roll
        )));
        lines.push(Line::from(format!(
            "インロール: {:.1} x{:.1} (inroll/roll)",
            s.inroll, weights.inroll
        )));
        lines.push(Line::from(format!(
            "アルペジオ: {:.1} x{:.1} (arpeggio/bigram)",
            s.arpeggio, weights.arpeggio
        )));
    } else {
        lines.push(Line::from("重み情報なし"));
    }

    let paragraph = Paragraph::new(lines).block(
        Block::default()
            .borders(Borders::ALL)
            .title("Similarity & Scores"),
    );

    f.render_widget(paragraph, area);
}

/// TUIスレッドを実行
pub fn run_tui_thread(state: Arc<Mutex<TuiState>>) -> std::thread::JoinHandle<()> {
    std::thread::spawn(move || {
        let mut app = match TuiApp::new() {
            Ok(app) => app,
            Err(e) => {
                eprintln!("TUI error: {}", e);
                return;
            }
        };

        loop {
            {
                let state = state.lock().unwrap();
                if !state.running {
                    break;
                }
                if let Err(e) = app.draw(&state) {
                    eprintln!("TUI draw error: {}", e);
                    break;
                }
            }

            match app.poll_event() {
                Ok(true) => {
                    let mut state = state.lock().unwrap();
                    state.running = false;
                    break;
                }
                Err(e) => {
                    eprintln!("TUI event error: {}", e);
                    break;
                }
                _ => {}
            }

            std::thread::sleep(std::time::Duration::from_millis(50));
        }

        if let Err(e) = app.cleanup() {
            eprintln!("TUI cleanup error: {}", e);
        }
    })
}
